<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: functional | Still Testing]]></title>
  <link href="http://chreekat.github.com/blog/categories/functional/atom.xml" rel="self"/>
  <link href="http://chreekat.github.com/"/>
  <updated>2012-03-01T18:51:24-08:00</updated>
  <id>http://chreekat.github.com/</id>
  <author>
    <name><![CDATA[Bryan Richter]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ditching the Imperative]]></title>
    <link href="http://chreekat.github.com/blog/2012/03/01/ditching-the-imperative/"/>
    <updated>2012-03-01T11:40:00-08:00</updated>
    <id>http://chreekat.github.com/blog/2012/03/01/ditching-the-imperative</id>
    <content type="html"><![CDATA[<h2>Problems</h2>

<p>I still have a bad habit of busting out code that wants to branch a lot, because
my inner dialogue is still imperative. "If this is true, then if that is true, then
for all of those, do these things."</p>

<p>My intuition is slowly changing. I know to substitute "for all of those, do these
things" into "map these over those", but I still struggle with the "if, if,
else, if, else". This is especially true with switching statements.</p>

<p>For instance, right now I have</p>

<p>```haskell</p>

<p>  let a = "cromulent" in do</p>

<pre><code>x &lt;- getX
y &lt;- getY
z &lt;- getZ
case requestType of
    "x" -&gt;
        res &lt;- runX
        case errorCondition res of
            Nothing -&gt;
                case otherCondition of
                    Foo -&gt; do
                        doThingsWithX_and_Y
                        ...
                    Bar -&gt; do
                        doThingsWithA_and_Z
                        ...
            _ -&gt; ...
    "y" -&gt;
        res &lt;- runY
        case errorCondition res of
            Nothing -&gt;
                case yetAnotherCondition of
                    Baz -&gt; do
                        doThingsWithZ_and_Y
                        ...
                    Quux -&gt; do
                        doThingsWithX_and_A
                        ...
            _ -&gt; ...
    _ -&gt; blarg
</code></pre>

<p>```</p>

<p>I find that to be incredibly ugly code. Why? Two reasons. One: I may no longer
be a C programmer (if I ever was one) but I still agree with Linus that "If you
need more than three levels of indent, you're screwed anyway, and should fix
your program." This code has seven!</p>

<p>I could fix this first problem by hacking off some of the indent levels and
putting them in a new function, i.e.</p>

<p>```haskell</p>

<p>  let a = "cromulent" in do</p>

<pre><code>x &lt;- getX
y &lt;- getY
z &lt;- getZ
case requestType of
    "x" -&gt; processX x y z
    "y" -&gt; processY x y z
    _ -&gt; blarg
</code></pre>

<p>processX x y z a = ...</p>

<pre><code>res &lt;- runX
case errorCondition res of
    Nothing -&gt;
        case otherCondition of
            Foo -&gt; do
                doThingsWithX_and_Y
                ...
            Bar -&gt; do
                doThingsWithA_and_Z
                ...
    _ -&gt; ...
</code></pre>

<p>processY x y z a = ...</p>

<pre><code>res &lt;- runY
case errorCondition res of
    Nothing -&gt;
        case yetAnotherCondition of
            Baz -&gt; do
                doThingsWithZ_and_Y
                ...
            Quux -&gt; do
                doThingsWithX_and_A
                ...
    _ -&gt; ...
</code></pre>

<p>```</p>

<p>However, that brings me to the second reason I think this is ugly code. Even
when chopped into bitty functions, it's still too imperative. If I simply chop
out segments of the logic and put them in small functions, I haven't gotten rid
of the underlying problem, which is too-deep, "turn left then turn right" code.
Plus I've created a bunch of functions that are useless in general, and are so
strongly connected to their callers that in practice I end up needing to pass a
ton of variables.</p>

<h2>Solutions</h2>

<p>So let's fix up this code, and hopefully improve my intuition in the process.</p>

<p>One helpful idea occurred to me right away: use closures and define the shrimpy
functions under a 'where'. So the previous becomes:</p>

<p>```haskell</p>

<p>  let a = "cromulent" in do</p>

<pre><code>x &lt;- getX
y &lt;- getY
z &lt;- getZ
case requestType of
    "x" -&gt; processX
    "y" -&gt; processY
    _ -&gt; blarg
</code></pre>

<p>  where</p>

<pre><code>processX = ...
    res &lt;- runX
    case errorCondition res of
        Nothing -&gt;
            case otherCondition of
                Foo -&gt; do
                    doThingsWithX_and_Y
                    ...
                Bar -&gt; do
                    doThingsWithA_and_Z
                    ...
        _ -&gt; ...

processY = ...
    res &lt;- runY
    case errorCondition res of
        Nothing -&gt;
            case yetAnotherCondition of
                Baz -&gt; do
                    doThingsWithZ_and_Y
                    ...
                Quux -&gt; do
                    doThingsWithX_and_A
                    ...
        _ -&gt; ...
</code></pre>

<p>```</p>

<p>That strikes me as a reasonable change that alleviates the indentation problem.
Those specific, tightly coupled functions one must create now get access to
variables in the outer scope, and aren't visible outside of that scope.</p>

<p>But, I still feel this is too imperative. (There's another problem, too. This
won't compile for reasons I'll get to below. But let's stick to the ugly factor
for now.) Can I do better than "If this then do that else do this?"</p>

<p>Next insight: To make this more declarative and functional, I can take the case
switiching out of my <em>manual</em> control and put it into the capable hands of the
compiler. That means pattern matching on function arguments. So now:</p>

<p>```haskell</p>

<p>  let a = "cromulent" in do</p>

<pre><code>x &lt;- getX
y &lt;- getY
z &lt;- getZ
processRequest requestType
</code></pre>

<p>  where</p>

<pre><code>processRequest "x" = ...
    res &lt;- runX
    case errorCondition res of
        Nothing -&gt;
            case otherCondition of
                Foo -&gt; do
                    doThingsWithX_and_Y
                    ...
                Bar -&gt; do
                    doThingsWithA_and_Z
                    ...
        _ -&gt; ...
processRequest "y" = ...
    res &lt;- runY
    case errorCondition res of
        Nothing -&gt;
            case yetAnotherCondition of
                Baz -&gt; do
                    doThingsWithZ_and_Y
                    ...
                Quux -&gt; do
                    doThingsWithX_and_A
                    ...
processRequest _ = blarg
</code></pre>

<p>```</p>

<p>This is shorter and more declarative. I could iterate the process to remove the
inner case statements, too.</p>

<p>The take away from this is: <strong>when I feel like writing a case statement, I should
instead write a function with argument pattern-matching.</strong></p>

<p>Except there's a compilation problem, as mentioned above. When I was going on
about closures, and variables being available in inner functions, I confused
'let' and 'where' variables with 'do' variables. In the examples above, <code>x</code>, <code>y</code>,
and <code>z</code> are out of scope in <code>processRequest</code>! To see why, consider this smaller
example:</p>

<p>```haskell</p>

<p>broken = do</p>

<pre><code>x &lt;- someAught
runIt
</code></pre>

<p>  where</p>

<pre><code>runIt = someProcess x
</code></pre>

<p>```</p>

<p>This doesn't work because <code>x</code> is not local to the "scope" as defined by indenting
-- it's local to the monad that is running. <code>runIt</code> is defined external to the
action going on inside to the 'do', so it doesn't get to see <code>x</code>. If we
de-sugar, we see</p>

<p>```haskell</p>

<p>broken = someAught >= (\x -> runIt)
  where</p>

<pre><code>runIt = someProcess x -- Not in scope: `x'
</code></pre>

<p><code>``
This is annoying when, for example, all of my deeper code (like the bodies of
</code>processRequest<code>above) want the result of the same computations. If every
branch of code uses</code>runX<code>and</code>runY`, must I write the code to run those
actions in each body separately? Where's the code sharing?</p>

<p>I haven't figured a good solution to this yet.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[More Fun with Yesod Authorization]]></title>
    <link href="http://chreekat.github.com/blog/2012/02/02/fun-with-yesod-authorization/"/>
    <updated>2012-02-02T00:00:00-08:00</updated>
    <id>http://chreekat.github.com/blog/2012/02/02/fun-with-yesod-authorization</id>
    <content type="html"><![CDATA[<p>I was inspired by Felipe Lessa's post about
<a href="http://blog.felipe.lessa.nom.br/?p=7">abstracting Yesod permissions</a>. Thanks
for writing it, Felipe! I had only just discovered <code>isAuthorized</code>, and that post
made me all the more excited to go about refactoring my authorization code.</p>

<p>Unfortunately I had a little trouble working Felipe's method into my own
project. This was probably due in no small part to my too-recent discovery of
<code>isAuthorized</code> and the <code>AuthResult</code> type. After much tinkering, I narrowed the
difficulties down to just one (and a half) points of contention:</p>

<ol>
<li>Permission values are taken to mean actions: "Permission to &lt;do
action&gt;". But RESTful routes are <em>also</em> taken to mean actions. The
arguments <code>BlogR True</code> clearly mean "Write to BlogR." Thus,
<code>permissionsRequiredFor</code> provides superfluous information. <code>Post</code> == <code>BlogR
True</code> == "Post a Blog".</li>
<li>(Actually 1.5) To paraphrase hlint, "Why not foldM?" :)</li>
</ol>


<p>To resolve the first point, I propose this:</p>

<p>``` haskell
-- Permission replacement
data Credential = LoggedIn | IsAdmin</p>

<h2>-- permissionsRequiredFor replacement</h2>

<p>requiredCredentials :: Route Blog -> Bool -> [Credential]
requiredCredentials BlogR      True = [IsAdmin]
requiredCredentials (EntryR _) True = [LoggedIn]
requiredCredentials _          _    = []
```</p>

<p>Note that this new function does the same thing as the one it replaces, but
reading it gives us more information: we know the action from the route, and
we also know what credentials a user needs to perform that action.</p>

<p>If that doesn't immediately seem crucial, consider that many actions may be
satisfied by the same credential. If I have a box with a key, it is assumed that
I may do anything with the <em>contents</em> of that box provided I have the key. In
other words,</p>

<p>``` haskell
data Credentials = HasKey</p>

<p>requiredCredentials PutInBoxR ... = [HasKey BoxID]
requiredCredentials TakeFromBoxR  = [HasKey BoxID]
```</p>

<p>With Permissions, either you write separate permissions that do the same thing
(GetBox, PutBox), or you break your semantic model and use a single Permission
for both ("permission to Box?")</p>

<p>For the second point, note that <code>isAuthorizedTo</code> can be written like so (with a
couple more name changes to sound sensible with <code>Credential</code>):</p>

<p>``` haskell
isAuthorizedTo :: Maybe (Entity User)</p>

<pre><code>           -&gt; [Credential]
           -&gt; YesodDB sub Blog AuthResult
</code></pre>

<p>Nothing <code>isAuthorizedTo</code> _  = return AuthenticationRequired
Just u  <code>isAuthorizedTo</code> ps = foldM hasCred Authorized ps
  where</p>

<pre><code>hasCred Authorized p = u `hasCredential` p
hasCred badAuth    _ = return badAuth
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
